package com.squaretrade.deploy.mock

import java.util.regex.Matcher
import java.util.regex.Pattern

/**
 * FIXME: move to test directory; update gradle
 */
class MockUtils {

    static def mockLibraryResource(GroovyObject obj) {
        obj.metaClass.libraryResource { String path ->
            return obj.class.getClassLoader().getResourceAsStream(path).getText("UTF-8")
        }
    }

    static def mockSh(GroovyObject obj, String workingDir = null) {
        obj.metaClass.sh { String command ->
            runShCommand(command, workingDir)
        }
    }

    static def mockSh2(GroovyObject obj) {
        obj.metaClass.sh { Map conf ->
            runShCommand2(conf.script, conf.returnStdout)
        }
    }

    static def mockEcho(GroovyObject obj){
        obj.metaClass.echo { String message ->
            println message
        }
    }

    static def mockEmailExt(GroovyObject obj) {
        obj.metaClass.emailext { Map email -> println "Mail Sent!"}
    }

    static def mockProperties(GroovyObject obj, Map properties) {
        properties.each {key, value ->
            obj.metaClass."$key" = value
        }
    }


    static def runShCommand2(String script, boolean returnStdout = false, boolean returnStatus = false, String workingDir = null) {
        println "running command: ${script}"

        ArrayList<String> matchList = getCommandLineParameters(script)

        ProcessBuilder procBuilder = new ProcessBuilder(matchList)

        if (workingDir) {
            procBuilder.directory(new File(workingDir))
        }

        Process proc = procBuilder.start()

        if (returnStdout) {
            BufferedReader buffReader = new BufferedReader(new InputStreamReader(proc.getInputStream()))

            StringBuilder strBuilder = new StringBuilder()

            String line
            while((line = buffReader.readLine()) != null) {
                strBuilder.append(line)

                strBuilder.append(System.getProperty("line.separator"))
            }

            println strBuilder.toString()
            return strBuilder.toString().trim()
        }
        if (returnStatus) {
            return proc.waitFor()
        }
    }

    static int runShCommand(String command, String workingDir = null) {
        println "running command: ${command}"

        ArrayList<String> matchList = getCommandLineParameters(command)

        ProcessBuilder proc = new ProcessBuilder(matchList).inheritIO()

        if (workingDir) {
            proc.directory(new File(workingDir))
        }

        proc.start().waitFor()
    }

    private static ArrayList<String> getCommandLineParameters(String command) {
        List<String> matchList = new ArrayList<String>()

        /*
        This regex is needed because ProcessBuilder expects a List<String> or String..., in our case the simplest
        way to generate the expected parameter for ProcessBuilder is splitting the string that is being passed to "sh" function
        performing a "command.split()", however our string contains a "git tag" command that needs a "-m" parameter,
        and the value for this parameter must be provided between quotes.

        Command string: "git tag -a ${tagName} -m \"Generated by Cloudbees ${getJobBaseName(jobName)} job: ${buildNumber}\""

        Using "command.split()" the returned List<String> is:
           command.split() e.g: ["git", "tag", "-a", "${tagName}", "-m", "\"Generated", "by", "Cloudbees", "${getJobBaseName(jobName)}", "job:", "${buildNumber}\""]
        Which causes a syntax error in the command returning a "fatal: too many params" error.

        Also, the use of a simple "command" returns another error: "git tag -a ... doesn't exist", because "comannd" is a simple String object, not the expected List<String>.

        To solve that I had to create this regex, which will split the given string by its whitespaces, ignoring anything between quotes, even if they are single quoted '', or double quoted "".

        Using the regex below, the returned List<String> will be:
            Regex return e.g: ["git", "tag", "-a", "${tagName}", "-m", "\"Generated by Cloudbees ${getJobBaseName(jobName)} job: ${buildNumber}\""]
        Which will return the correct syntax to execute the command.
        */
        Pattern regex = Pattern.compile("[^\\s\"']+|\"[^\"]*\"|'[^']*'")

        Matcher regexMatcher = regex.matcher(command)

        while (regexMatcher.find()) {
            matchList.add(regexMatcher.group())
        }
        matchList
    }


    static class TestMockUtils {
        def execShellScript() {
            sh 'ls -al'
        }

        def failShellScript() {
            sh 'ls fail'
        }

        def failShellScriptWithCode() {
            sh script: 'ls fail', returnStatus: true
        }

        def echoBob() {
            sh script: 'echo bob', returnStdout: true
        }
    }


    static void main(String[] args) {
        TestMockUtils mockTest = new TestMockUtils()

        mockSh(mockTest)
        assert mockTest.execShellScript() == 0
        assert mockTest.failShellScriptWithCode() == 1
        assert mockTest.echoBob().trim() == 'bob'
        try {
            mockTest.failShellScript()
            assert false
        }
        catch (t) {

        }
    }
}